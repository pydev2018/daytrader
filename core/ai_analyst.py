"""
===============================================================================
  AI Analyst — OpenAI-powered market analysis layer
===============================================================================
  Uses GPT-4o to:
  • Summarise complex multi-indicator setups in plain English
  • Parse and interpret economic news / fundamental data
  • Provide a second opinion on high-confidence trades
  • Generate daily market briefings
===============================================================================
"""

from __future__ import annotations

import json
from typing import Optional

import config as cfg
from utils.logger import get_logger

log = get_logger("ai_analyst")

# Lazy import — only load openai when actually called
_client = None


def _get_client():
    global _client
    if _client is None:
        if not cfg.OPENAI_API_KEY:
            log.warning("OpenAI API key not set — AI analyst disabled")
            return None
        try:
            from openai import OpenAI
            _client = OpenAI(api_key=cfg.OPENAI_API_KEY)
        except ImportError:
            log.warning("openai package not installed — AI analyst disabled")
            return None
    return _client


def _ask(system_prompt: str, user_prompt: str, max_tokens: int = 1024) -> Optional[str]:
    """Send a prompt to OpenAI and return the response text."""
    client = _get_client()
    if client is None:
        return None
    try:
        resp = client.chat.completions.create(
            model=cfg.OPENAI_MODEL,
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt},
            ],
            max_completion_tokens=max_tokens,  # GPT-5.2 uses max_completion_tokens
            temperature=0.3,
        )
        return resp.choices[0].message.content.strip()
    except Exception as e:
        log.error(f"OpenAI API error: {e}")
        return None


# ═════════════════════════════════════════════════════════════════════════════
#  TRADE VALIDATION
# ═════════════════════════════════════════════════════════════════════════════

TRADE_REVIEW_SYSTEM = """You are an elite institutional FX trader and risk manager.
You are reviewing a trade signal generated by an algorithmic system.
Analyse the setup and give your professional opinion.
Be brutally honest. If the trade looks weak, say so.
if the trade is strong, say so.
Reply with a JSON object:
{
  "approval": true/false,
  "confidence_adjustment": <int -20 to +10>,
  "reasoning": "<2-3 sentences>",
  "risk_notes": "<any risk concerns>"
}"""


def review_trade(signal_data: dict) -> Optional[dict]:
    """
    Ask GPT to review a trade signal and return its assessment.
    Returns dict with approval, confidence_adjustment, reasoning.
    """
    prompt = (
        f"Review this trade signal:\n"
        f"```json\n{json.dumps(signal_data, indent=2, default=str)}\n```\n"
        f"Current UTC time context: consider market sessions and timing."
    )
    text = _ask(TRADE_REVIEW_SYSTEM, prompt)
    if text is None:
        return None

    # Parse JSON from response
    try:
        # Handle markdown code blocks
        if "```" in text:
            text = text.split("```")[1]
            if text.startswith("json"):
                text = text[4:]
        return json.loads(text.strip())
    except (json.JSONDecodeError, IndexError):
        log.warning(f"Failed to parse AI review response: {text[:200]}")
        return None


# ═════════════════════════════════════════════════════════════════════════════
#  MARKET BRIEFING
# ═════════════════════════════════════════════════════════════════════════════

BRIEFING_SYSTEM = """You are a senior market analyst at a major trading desk.
Provide a concise morning briefing based on the technical data provided.
Focus on: key levels, likely moves, best opportunities, and risks.
Keep it under 300 words. Use bullet points."""


def generate_market_briefing(scan_summary: list[dict]) -> Optional[str]:
    """Generate a daily market briefing from scanner data."""
    if not scan_summary:
        return None

    prompt = (
        f"Here are the top opportunities from today's scan:\n"
        f"```json\n{json.dumps(scan_summary[:10], indent=2, default=str)}\n```\n"
        f"Provide a morning briefing for today's trading session."
    )
    return _ask(BRIEFING_SYSTEM, prompt, max_tokens=800)


# ═════════════════════════════════════════════════════════════════════════════
#  NEWS / FUNDAMENTAL ANALYSIS
# ═════════════════════════════════════════════════════════════════════════════

NEWS_SYSTEM = """You are a financial news analyst.
Given the following news headlines/data, determine:
1. Which currency pairs or instruments are most affected
2. The likely directional impact (bullish/bearish) on each
3. Whether traders should avoid trading certain pairs right now

Reply with JSON:
{
  "affected_instruments": [{"symbol": "...", "impact": "bullish/bearish", "severity": "high/medium/low"}],
  "avoid_trading": ["symbol1", "symbol2"],
  "summary": "<brief summary>"
}"""


def analyze_news(news_text: str) -> Optional[dict]:
    """Analyze news text for trading implications."""
    text = _ask(NEWS_SYSTEM, news_text)
    if text is None:
        return None
    try:
        if "```" in text:
            text = text.split("```")[1]
            if text.startswith("json"):
                text = text[4:]
        return json.loads(text.strip())
    except (json.JSONDecodeError, IndexError):
        return None


# ═════════════════════════════════════════════════════════════════════════════
#  TRADE JOURNAL ANALYSIS
# ═════════════════════════════════════════════════════════════════════════════

JOURNAL_SYSTEM = """You are a trading performance coach.
Analyse the recent trade journal data and provide:
1. Win rate and key statistics
2. Patterns in winning vs losing trades
3. Specific recommendations to improve performance
Keep it actionable and concise."""


def analyze_journal(trades: list[dict]) -> Optional[str]:
    """Analyze trading journal for performance insights."""
    if not trades:
        return None
    # Only send last 50 trades to stay within token limits
    recent = trades[-50:]
    prompt = (
        f"Here are the recent {len(recent)} trades:\n"
        f"```json\n{json.dumps(recent, indent=2, default=str)}\n```"
    )
    return _ask(JOURNAL_SYSTEM, prompt, max_tokens=1024)
